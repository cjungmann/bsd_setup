#!/usr/bin/env bash

declare T_UP_ARROW=$'\e[A'
declare T_TAB=$'\t'

declare T_DOWN_ARROW=$'\e[B'
declare T_SHIFT_TAB=$'\e[Z'

declare T_INTRO=""
declare T_PROMPT="Arrow keys to move, SPACE to toggle, ENTER to use values, 'q' to quit"


reset_screen() { echo -n "[2J[1;1H"; }

# Waits for and returns single keypress, even if it is
# represented by multiple characters.
get_keypress()
{
    local IFS=''
    local -a chars=( )
    
    local keychar
    read -n 1 -s keychar
    chars=( "$keychar" )

    while read -t 0; do
        read -n 1 keychar
        chars=( "${chars[@]}" "$keychar" )
    done

    echo "${chars[*]}"
}

# Print a single choice, called by function toggler_print_choices()
#
# A new implementation will likely need to change or replace this
# function to generate options according to the new need.
toggler_print_choice()
{
    local key="$1"
    local -i value="$2" hilite="$3"
    local prefix
    if [ "$hilite" -ne 0 ]; then
        echo -n "[43m"
    fi
    
    if [ "$value" -eq 0 ]; then
        prefix="[31;1mNOT selected"
    else
        prefix="[32;1mSelected"
    fi
    echo "$prefix $key[m"
}

# Prints all options, using the keys array for order and the choices
# associative array for the values.
toggler_print_choices()
{
    local keys_name="$1"
    local choices_name="$2"
    local -n keys="$keys_name"
    local -n choices="$choices_name"
    local -i selected="$3"
    local key
    local -i count=0 hilite

    for key in "${keys[@]}"; do
        if [ "$(( count++ ))" -eq "$selected" ]; then
            hilite=1
        else
            hilite=0
        fi
        toggler_print_choice "$key" "${choices[$key]}" "$hilite"
    done
    
}

# Toggles the specified value
toggler_switch_choice()
{
    local -n keys="$1"
    local -n choices="$2"
    local -i ndx="$3"

    local key="${keys[$ndx]}"

    choices[$key]=$(( (${choices[$key]} + 1) % 2 ))
}

# Initialize the associative array passed to function toggler()
toggler_map_guidance()
{
    local -n choices="$1"
    local -n results="$2"
    local key

    for key in "${choices[@]}"; do
        results[$key]=0
    done
}

#####################################################################################
# Create a arrow-key navigated list of switches to collect user input.
# Arguments:
#    $1 (array):             name of array of strings to be used as keys
#    $2 (associative array): name of associative array in which user
#                            responses will be stored.  Typically, the calling
#                            function will reference an empty array which will
#                            be initialized and filled in this function (toggler()).
#
# The result of this function will be found in the instance of the associative
# array whose name was passed as the second argument in the call to this function.
#####################################################################################
toggler()
{
    toggler_map_guidance "$1" "$2"

    local list_name="$1"
    local result_name="$2"
    
    local -n keys="$list_name"
    local -n choices="$result_name"

    local -i limit=$(( "${#keys[@]}" - 1 ))
    local -i hilite=0
    local keyp

    while [ 1 -eq 1 ]; do
        reset_screen
        if [ "$T_INTRO" ]; then echo "$T_INTRO"; fi
        toggler_print_choices $list_name $result_name $hilite
        if [ "$T_PROMPT" ]; then echo "$T_PROMPT"; fi

        keyp=$( get_keypress )
        if [ "${#keyp}" -eq 0 ]; then
            return 0
        else
            case "$keyp" in
                $T_UP_ARROW | $T_SHIFT_TAB )
                    if [ "$hilite" -gt 0 ]; then
                        hilite=$(( hilite - 1 ))
                    fi
                    ;;
                
                $T_DOWN_ARROW | $T_TAB )
                    if [ "$hilite" -lt "$limit" ]; then
                        hilite=$(( hilite + 1 ))
                    fi
                    ;;
                
                ' ' ) toggler_switch_choice "$list_name" "$result_name" $hilite ;;
                'q' ) return 1 ;;
            esac
        fi
    done
}

